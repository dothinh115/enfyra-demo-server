name: Deploy to VPS

on:
  schedule:
    - cron: '0 * * * *'
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write 
      pull-requests: read
    
    outputs:
      should_notify: ${{ steps.set_notify_flag.outputs.should_notify }}
      deploy_status: ${{ steps.set_notify_flag.outputs.deploy_status }}
      deploy_reason: ${{ steps.set_notify_flag.outputs.deploy_reason }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true  

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config pull.rebase false  # Use merge strategy

      - name: Add upstream remote if not exists
        run: |
          if ! git remote | grep -q upstream; then
            echo "Adding upstream remote..."
            git remote add upstream https://github.com/enfyra/backend.git
          else
            echo "Upstream remote already exists"
          fi
          git remote set-url upstream https://github.com/enfyra/backend.git
          git fetch upstream

      - name: Check for new commits in upstream main
        id: check-commits
        run: |
          # Always track upstream main
          UPSTREAM_BRANCH="main"

          if ! git fetch upstream "$UPSTREAM_BRANCH" 2>/dev/null; then
            echo "Could not fetch upstream main"
            echo "has_new_commits=false" >> $GITHUB_OUTPUT
            echo "upstream_branch=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          UPSTREAM_COMMIT=$(git rev-parse upstream/main 2>/dev/null || echo "")
          
          if [ -z "$UPSTREAM_COMMIT" ]; then
            echo "Could not resolve upstream main commit"
            echo "has_new_commits=false" >> $GITHUB_OUTPUT
            echo "upstream_branch=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Found upstream branch: $UPSTREAM_BRANCH"
          echo "upstream_branch=$UPSTREAM_BRANCH" >> $GITHUB_OUTPUT
          
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          CURRENT_COMMIT=$(git rev-parse HEAD)
          
          # Simple rule: if current commit differs from upstream/main, treat as new changes
          if [ "$CURRENT_COMMIT" != "$UPSTREAM_COMMIT" ]; then
            echo "has_new_commits=true" >> $GITHUB_OUTPUT
            echo "upstream_commit=$UPSTREAM_COMMIT" >> $GITHUB_OUTPUT
            echo "current_commit=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
            echo "Found new commits from upstream main (commit mismatch)"
          else
            echo "has_new_commits=false" >> $GITHUB_OUTPUT
            echo "No new commits found (HEAD equals upstream/main)"
          fi

      - name: Pull and merge from upstream
        if: steps.check-commits.outputs.has_new_commits == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          UPSTREAM_BRANCH="${{ steps.check-commits.outputs.upstream_branch }}"
          
          echo "Current branch: $CURRENT_BRANCH"
          echo "Upstream branch: $UPSTREAM_BRANCH"
          
          if [ -z "$UPSTREAM_BRANCH" ]; then
            echo "Upstream branch not found, cannot pull"
            exit 1
          fi
          
          # Pull with merge strategy (already configured)
          git pull --no-rebase upstream "$UPSTREAM_BRANCH" || {
            echo "Failed to pull from upstream $UPSTREAM_BRANCH"
            exit 1
          }
          
          # Configure remote URL with token for push
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
          
          git push origin $CURRENT_BRANCH || {
            echo "Failed to push to origin"
            exit 1
          }
          
          echo "Successfully pulled and pushed new code from upstream $UPSTREAM_BRANCH"

      - name: Install sshpass
        run: |
          sudo apt-get update -y
          sudo apt-get install -y sshpass

      - name: Deploy to VPS via sshpass
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          EVENT_NAME="${{ github.event_name }}"
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no $VPS_USER@$VPS_HOST "bash -s \"$EVENT_NAME\"" <<'ENDSSH'
            # Set project variables
            export PROJECT_NAME="demo-server"
            export APP_DIR="/apps/demo-server"
            export EVENT_NAME="$1"
            export PATH="$PATH:/usr/bin:/usr/local/bin:$HOME/.local/bin"

            # Find tool paths
            GIT_PATH=$(which git || echo "/usr/bin/git")
            NPM_PATH=$(which npm || echo "/usr/bin/npm")
            YARN_PATH=$(which yarn || echo "")
            PM2_PATH=$(which pm2 || echo "$HOME/.local/bin/pm2")

            # Install yarn if not found
            if [ -z "$YARN_PATH" ]; then
              echo "Yarn not found, installing..."
              $NPM_PATH install -g yarn
              YARN_PATH=$(which yarn || echo "$HOME/.local/bin/yarn")
            fi

            echo "=== Deploy triggered by $EVENT_NAME ==="
            echo "Tools found:"
            echo "Git: $GIT_PATH"
            echo "NPM: $NPM_PATH"
            echo "Yarn: $YARN_PATH"
            echo "PM2: $PM2_PATH"

            cd $APP_DIR
            echo "Current directory: $(pwd)"

            $GIT_PATH checkout main 2>/dev/null || true

            # Pull latest code with conflict resolution
            echo "Pulling latest code..."
            # Stash any local changes to avoid conflicts
            $GIT_PATH stash || true
            # Fetch latest from origin
            $GIT_PATH fetch origin main
            # Reset to origin/main (discard local changes)
            $GIT_PATH reset --hard origin/main
            # Clean untracked files
            $GIT_PATH clean -fd
            echo "Code updated to latest from git (local changes discarded)"

            echo "Installing dependencies with yarn..."
            $YARN_PATH install --frozen-lockfile

            echo "Setting up environment..."
            if [ ! -f .env ]; then
              echo ".env file not found! Creating from template..."
              cp env_example .env || echo "env_example not found, manual .env setup required"
            fi

            echo "Building application..."
            $YARN_PATH build

            echo "Stopping PM2 application..."
            $PM2_PATH stop $PROJECT_NAME || true
            $PM2_PATH delete $PROJECT_NAME || true

            echo "Starting PM2 application clean..."
            $PM2_PATH start ecosystem.config.js

            echo "Waiting for app to initialize..."
            sleep 10

            $PM2_PATH status

            echo "=== Health Check ==="
            sleep 5
            if $PM2_PATH show $PROJECT_NAME | grep -q "online"; then
              echo "Application is running successfully"
            else
              echo "Application failed to start"
              $PM2_PATH logs $PROJECT_NAME --lines 20 --nostream
              exit 1
            fi

            echo "=== Recent logs ==="
            $PM2_PATH logs $PROJECT_NAME --lines 30 --nostream || {
              echo "Using alternative log method..."
              timeout 3s $PM2_PATH logs $PROJECT_NAME --lines 30 || true
            }

            echo "=== PM2 Deployment completed successfully ==="
          ENDSSH

      - name: Set notification flag
        id: set_notify_flag
        if: always()  
        run: |
          # Check whether a deployment actually happened
          SHOULD_NOTIFY="false"
          DEPLOY_STATUS="skipped"
          DEPLOY_REASON="No changes detected"
          
          # Case 1: New commits from upstream
          if [ "${{ steps.check-commits.outputs.has_new_commits }}" == "true" ]; then
            SHOULD_NOTIFY="true"
            DEPLOY_STATUS="success"
            DEPLOY_REASON="New commits from upstream"
          # Case 2: Manual push to main
          elif [ "${{ github.event_name }}" == "push" ]; then
            SHOULD_NOTIFY="true"
            DEPLOY_STATUS="success"
            DEPLOY_REASON="Manual push to main"
          # Case 3: Manual workflow dispatch
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SHOULD_NOTIFY="true"
            DEPLOY_STATUS="success"
            DEPLOY_REASON="Manual workflow dispatch"
          fi
          
          # Always notify if the job failed
          if [ "${{ job.status }}" == "failure" ]; then
            SHOULD_NOTIFY="true"
            DEPLOY_STATUS="failed"
          fi
          
          echo "should_notify=$SHOULD_NOTIFY" >> $GITHUB_OUTPUT
          echo "deploy_status=$DEPLOY_STATUS" >> $GITHUB_OUTPUT
          echo "deploy_reason=$DEPLOY_REASON" >> $GITHUB_OUTPUT
          
          echo "Notification flag: $SHOULD_NOTIFY"
          echo "Deploy status: $DEPLOY_STATUS"
          echo "Deploy reason: $DEPLOY_REASON"

      - name: Deploy notification
        if: steps.check-commits.outputs.has_new_commits == 'true'
        run: |
          echo "Successfully deployed new code from upstream main"
          echo "Upstream commit: ${{ steps.check-commits.outputs.upstream_commit }}"
          echo "Previous commit: ${{ steps.check-commits.outputs.current_commit }}"

      - name: Push notification
        if: github.event_name == 'push' && steps.check-commits.outputs.has_new_commits != 'true'
        run: |
          echo "Deployed code from main branch push"

      - name: Manual deploy notification
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Deployed code from manual workflow dispatch"

      - name: No updates notification
        if: steps.check-commits.outputs.has_new_commits == 'false' && github.event_name == 'schedule'
        run: |
          echo "ℹ️ No new code from upstream, skipping deployment"
